from contextlib import AbstractContextManager
from types import TracebackType
from . import ordlookup as ordlookup
from typing import Any, Callable, Literal, ParamSpec, Self, TypeVar, TypedDict, overload
from _typeshed import ReadableBuffer
from hashlib import _Hash

_P = ParamSpec("_P")
_T = TypeVar("_T")
_K = TypeVar("_K")
_V = TypeVar("_V")
_DATA_TYPE = ReadableBuffer
_DWORD = int
_WORD = int
_QWORD = int

__author__: str = ...
__version__: str = ...
__contact__: str = ...

long: type[int] = int

def lru_cache(
    maxsize: int = ..., typed: bool = ..., copy: bool = ...
) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]: ...
@lru_cache(maxsize=2048)
def cache_adjust_FileAlignment(val, file_alignment): ...
@lru_cache(maxsize=2048)
def cache_adjust_SectionAlignment(val, section_alignment, file_alignment): ...
def count_zeroes(data: list[int]) -> int: ...

fast_load: bool = ...
MAX_STRING_LENGTH: Literal[0x100000] = ...
MAX_IMPORT_SYMBOLS: Literal[0x2000] = ...
MAX_IMPORT_NAME_LENGTH: Literal[0x200] = ...
MAX_DLL_LENGTH: Literal[0x200] = ...
MAX_SYMBOL_NAME_LENGTH: Literal[0x200] = ...
MAX_SECTIONS: Literal[0x800] = ...
MAX_RESOURCE_ENTRIES: Literal[0x8000] = ...
MAX_RESOURCE_DEPTH: Literal[32] = ...
MAX_SYMBOL_EXPORT_COUNT: Literal[0x2000] = ...
IMAGE_DOS_SIGNATURE: Literal[0x5A4D] = ...
IMAGE_DOSZM_SIGNATURE: Literal[0x4D5A] = ...
IMAGE_NE_SIGNATURE: Literal[0x454E] = ...
IMAGE_LE_SIGNATURE: Literal[0x454C] = ...
IMAGE_LX_SIGNATURE: Literal[0x584C] = ...
IMAGE_TE_SIGNATURE: Literal[0x5A56] = ...
IMAGE_NT_SIGNATURE: Literal[0x00004550] = ...
IMAGE_NUMBEROF_DIRECTORY_ENTRIES: Literal[16] = ...
IMAGE_ORDINAL_FLAG: Literal[0x80000000] = ...
IMAGE_ORDINAL_FLAG64: Literal[0x8000000000000000] = ...
OPTIONAL_HEADER_MAGIC_PE: Literal[0x10B] = ...
OPTIONAL_HEADER_MAGIC_PE_PLUS: Literal[0x20B] = ...

def two_way_dict(pairs: list[tuple[_K, _V]]) -> dict[_K | _V, _K | _V]: ...

_NAME_LOOKUP_LIST = list[tuple[str, bytes]]
_NAME_LOOKUP = dict[str | bytes, str | bytes]

directory_entry_types: _NAME_LOOKUP_LIST = ...
DIRECTORY_ENTRY: _NAME_LOOKUP = ...
image_characteristics: _NAME_LOOKUP_LIST = ...
IMAGE_CHARACTERISTICS: _NAME_LOOKUP = ...
section_characteristics: _NAME_LOOKUP_LIST = ...
SECTION_CHARACTERISTICS: _NAME_LOOKUP = ...
debug_types: _NAME_LOOKUP_LIST = ...
DEBUG_TYPE: _NAME_LOOKUP = ...
subsystem_types: _NAME_LOOKUP_LIST = ...
SUBSYSTEM_TYPE: _NAME_LOOKUP = ...
machine_types: _NAME_LOOKUP_LIST = ...
MACHINE_TYPE: _NAME_LOOKUP = ...
relocation_types: _NAME_LOOKUP_LIST = ...
RELOCATION_TYPE: _NAME_LOOKUP = ...
dll_characteristics: _NAME_LOOKUP_LIST = ...
DLL_CHARACTERISTICS: _NAME_LOOKUP = ...
FILE_ALIGNMENT_HARDCODED_VALUE: Literal[0x200] = ...
unwind_info_flags: _NAME_LOOKUP_LIST = ...
UNWIND_INFO_FLAGS: _NAME_LOOKUP = ...
registers: _NAME_LOOKUP_LIST = ...
REGISTERS: _NAME_LOOKUP = ...
UWOP_PUSH_NONVOL: Literal[0] = ...
UWOP_ALLOC_LARGE: Literal[1] = ...
UWOP_ALLOC_SMALL: Literal[2] = ...
UWOP_SET_FPREG: Literal[3] = ...
UWOP_SAVE_NONVOL: Literal[4] = ...
UWOP_SAVE_NONVOL_FAR: Literal[5] = ...
UWOP_EPILOG: Literal[6] = ...
UWOP_SAVE_XMM128: Literal[8] = ...
UWOP_SAVE_XMM128_FAR: Literal[9] = ...
UWOP_PUSH_MACHFRAME: Literal[10] = ...
resource_type: _NAME_LOOKUP_LIST = ...
RESOURCE_TYPE: _NAME_LOOKUP = ...
lang: _NAME_LOOKUP_LIST = ...
LANG: _NAME_LOOKUP = ...
sublang: _NAME_LOOKUP_LIST = ...
SUBLANG: _NAME_LOOKUP = ...

sublang_name: Any
sublang_value: Any

def get_sublang_name_for_lang(
    lang_value: str | bytes, sublang_value: list[str]
) -> str: ...
def parse_strings(data: str, counter: int, l: list[bytes]) -> None: ...
def retrieve_flags(
    flag_dict: dict[str | bytes, str | bytes], flag_filter: str | bytes
) -> list[tuple[str | bytes, str | bytes]]: ...
def set_flags(obj: Any, flag_field: bytes, flags: list[tuple[str, bytes]]) -> None: ...
def power_of_two(val: bytes) -> bool: ...
def b(x: _DATA_TYPE) -> bytes: ...

class AddressSet(set[_T]):
    def __init__(self) -> None: ...
    def add(self, value: _T) -> None: ...
    def diff(self) -> _T: ...

class UnicodeStringWrapperPostProcessor:
    def __init__(self, pe: PE, rva_ptr: int) -> None: ...
    def get_rva(self) -> int: ...
    def __str__(self) -> str: ...
    def decode(self, *args: str) -> str: ...
    def invalidate(self) -> None: ...
    def render_pascal_16(self) -> None: ...
    def get_pascal_16_length(self) -> Any | Literal[False]: ...
    def ask_unicode_16(self, next_rva_ptr: int) -> bool: ...
    def render_unicode_16(self) -> None: ...

class PEFormatError(Exception):
    def __init__(self, value: Any) -> None: ...
    def __str__(self) -> str: ...

class Dump:
    def __init__(self) -> None: ...
    def add_lines(self, txt: list[str], indent: int = ...) -> None: ...
    def add_line(self, txt: str, indent: int = ...) -> None: ...
    def add(self, txt: str, indent: int = ...) -> None: ...
    def add_header(self, txt: str) -> None: ...
    def add_newline(self) -> None: ...
    def get_text(self) -> str: ...

STRUCT_SIZEOF_TYPES: dict[str, int] = ...

_STRUCTURE_FORMAT = tuple[str, tuple[str, ...]]

@lru_cache(maxsize=2048)
def sizeof_type(t): ...
@lru_cache(maxsize=2048, copy=True)
def set_format(format: _STRUCTURE_FORMAT): ...

class _Structure_Dict_Value(TypedDict):
    FileOffset: int
    Offset: int
    Value: str

class Structure:

    def __init__(
        self,
        format: _STRUCTURE_FORMAT,
        name: str | None = ...,
        file_offset: int | None = ...,
    ) -> None: ...
    def __get_format__(self) -> str: ...
    def get_field_absolute_offset(self, field_name: str) -> int: ...
    def get_field_relative_offset(self, field_name: str) -> int: ...
    def get_file_offset(self) -> int: ...
    def set_file_offset(self, offset: int) -> None: ...
    def all_zeroes(self) -> bool: ...
    def sizeof(self) -> int: ...
    def __unpack__(self, data: _DATA_TYPE) -> None: ...
    def __pack__(self) -> bytes: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def dump(self, indentation: int = ...) -> list[str]: ...
    def dump_dict(self) -> dict[str, str | _Structure_Dict_Value]: ...

class SectionStructure(Structure):

    def __init__(self, *argl: Any, **argd: Any) -> None: ...
    def get_PointerToRawData_adj(self) -> int: ...
    def get_VirtualAddress_adj(self) -> int: ...
    def get_data(
        self,
        start: int | None = ...,
        length: int | None = ...,
        ignore_padding: bool = ...,
    ) -> bytes: ...
    def __setattr__(self, name: str, val: Any) -> None: ...
    def get_rva_from_offset(self, offset: int) -> int: ...
    def get_offset_from_rva(self, rva: int) -> int: ...
    def contains_offset(self, offset: int) -> bool: ...
    def contains_rva(self, rva: int) -> bool: ...
    def contains(self, rva: int) -> bool: ...
    def get_entropy(self) -> float | Literal[0]: ...
    def get_hash_sha1(self) -> str | None: ...
    def get_hash_sha256(self) -> str | None: ...
    def get_hash_sha512(self) -> str | None: ...
    def get_hash_md5(self) -> str | None: ...
    def entropy_H(self, data: _DATA_TYPE) -> float | Literal[0]: ...

@lru_cache(maxsize=2048, copy=False)
def set_bitfields_format(
    format,
) -> tuple[
    str,
    int,
    dict[str, int],
    list[str],
    list[str],
    dict[int, tuple[str, list[tuple[str, int]]]],
]: ...

class StructureWithBitfields(Structure):
    BTF_NAME_IDX: Literal[0] = ...
    BTF_BITCNT_IDX: Literal[1] = ...
    CF_TYPE_IDX: Literal[0] = ...
    CF_SUBFLD_IDX: Literal[1] = ...
    def __init__(
        self,
        format: _STRUCTURE_FORMAT,
        name: str | None = ...,
        file_offset: int | None = ...,
    ) -> None: ...
    def __unpack__(self, data: _DATA_TYPE) -> None: ...
    def __pack__(self) -> bytes: ...
    def dump(self, indentation: int = ...) -> list[str]: ...
    def dump_dict(self) -> dict[str, str | _Structure_Dict_Value]: ...

class DataContainer:
    def __init__(self, **args: Any) -> None: ...


class ImportDescData(DataContainer): ...

class ImportData(DataContainer):
    def __setattr__(self, name: str, val: Any) -> None: ...

class ExportDirData(DataContainer): ...

class ExportData(DataContainer):
    def __setattr__(self, name: str, val: Any) -> None: ...

class ResourceDirData(DataContainer): ...
class ResourceDirEntryData(DataContainer): ...
class ResourceDataEntryData(DataContainer): ...
class DebugData(DataContainer): ...
class DynamicRelocationData(DataContainer): ...
class FunctionOverrideData(DataContainer): ...
class FunctionOverrideDynamicRelocationData(DataContainer): ...
class BddDynamicRelocationData(DataContainer): ...
class BaseRelocationData(DataContainer): ...

class RelocationData(DataContainer):
    def __setattr__(self, name: str, val: Any) -> None: ...

class TlsData(DataContainer): ...
class BoundImportDescData(DataContainer): ...
class LoadConfigData(DataContainer): ...
class BoundImportRefData(DataContainer): ...
class ExceptionsDirEntryData(DataContainer): ...

class UnwindInfo(StructureWithBitfields):
    def __init__(self, file_offset: int = ...) -> None: ...
    def unpack_in_stages(self, data: _DATA_TYPE) -> str | None: ...
    def dump(self, indentation: int = ...) -> list[str]: ...
    def dump_dict(self) -> dict[str, str | _Structure_Dict_Value]: ...
    def __setattr__(self, name: str, val: Any) -> None: ...
    def sizeof(self) -> int: ...
    def __pack__(self) -> bytes: ...
    def get_chained_function_entry(self) -> ExceptionsDirEntryData: ...
    def set_chained_function_entry(self, entry: ExceptionsDirEntryData) -> None: ...

class PrologEpilogOp:
    def initialize(
        self,
        unw_code: StructureWithBitfields,
        data: _DATA_TYPE,
        unw_info: UnwindInfo,
        file_offset: int | None,
    ) -> None: ...
    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def is_valid(self) -> bool: ...

class PrologEpilogOpPushReg(PrologEpilogOp):
    def __str__(self) -> str: ...

class PrologEpilogOpAllocLarge(PrologEpilogOp):
    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_alloc_size(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpAllocSmall(PrologEpilogOp):
    def get_alloc_size(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSetFP(PrologEpilogOp):
    def initialize(
        self,
        unw_code: StructureWithBitfields,
        data: _DATA_TYPE,
        unw_info: UnwindInfo,
        file_offset: int | None,
    ) -> None: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSaveReg(PrologEpilogOp):
    def length_in_code_structures(
        self, unwcode: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSaveRegFar(PrologEpilogOp):
    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSaveXMM(PrologEpilogOp):
    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSaveXMMFar(PrologEpilogOp):
    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpPushFrame(PrologEpilogOp):
    def __str__(self) -> str: ...

class PrologEpilogOpEpilogMarker(PrologEpilogOp):
    def initialize(
        self,
        unw_code: StructureWithBitfields,
        data: _DATA_TYPE,
        unw_info: UnwindInfo,
        file_offset: int | None,
    ) -> None: ...
    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __str__(self) -> str: ...

class PrologEpilogOpsFactory:
    _class_dict: dict[int, type[PrologEpilogOp]] = ...
    @staticmethod
    def create(unwcode: StructureWithBitfields) -> PrologEpilogOp: ...

allowed_filename: bytes = ...

def is_valid_dos_filename(s: str | bytes | bytearray) -> bool: ...

allowed_function_name: bytes = ...

@lru_cache(maxsize=2048)
def is_valid_function_name(
    s: str | bytes | bytearray, relax_allowed_characters: bool = ...
) -> bool: ...


class PE(AbstractContextManager["PE"]):
    __IMAGE_DOS_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_FILE_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DATA_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_OPTIONAL_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_OPTIONAL_HEADER64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_NT_HEADERS_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_SECTION_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DELAY_IMPORT_DESCRIPTOR_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_IMPORT_DESCRIPTOR_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_EXPORT_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_RESOURCE_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_RESOURCE_DIRECTORY_ENTRY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_RESOURCE_DATA_ENTRY_format__: _STRUCTURE_FORMAT = ...
    __VS_VERSIONINFO_format__: _STRUCTURE_FORMAT = ...
    __VS_FIXEDFILEINFO_format__: _STRUCTURE_FORMAT = ...
    __StringFileInfo_format__: _STRUCTURE_FORMAT = ...
    __StringTable_format__: _STRUCTURE_FORMAT = ...
    __String_format__: _STRUCTURE_FORMAT = ...
    __Var_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_THUNK_DATA_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_THUNK_DATA64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DEBUG_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BASE_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BASE_RELOCATION_ENTRY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_FUNCTION_OVERRIDE_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BDD_INFO_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BDD_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_TLS_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_TLS_DIRECTORY64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_LOAD_CONFIG_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_LOAD_CONFIG_DIRECTORY64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION_TABLE_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION_V2_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION64_V2_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BOUND_IMPORT_DESCRIPTOR_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BOUND_FORWARDER_REF_format__: _STRUCTURE_FORMAT = ...
    __RUNTIME_FUNCTION_format__: _STRUCTURE_FORMAT = ...
    @overload
    def __init__(
        self,
        name: str = ...,
        data: None = ...,
        fast_load: bool | None = ...,
        max_symbol_exports: int = ...,
        max_repeated_symbol: int = ...,
    ) -> None: ...
    @overload
    def __init__(
        self,
        name: None = ...,
        data: _DATA_TYPE = ...,
        fast_load: bool | None = ...,
        max_symbol_exports: int = ...,
        max_repeated_symbol: int = ...,
    ) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self,
        type: type[BaseException] | None,
        value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None: ...
    def close(self) -> None: ...
    def __unpack_data__(
        self, format: _STRUCTURE_FORMAT, data: _DATA_TYPE, file_offset: int
    ) -> Structure | None: ...
    def __unpack_data_with_bitfields__(
        self, format: _STRUCTURE_FORMAT, data: _DATA_TYPE, file_offset: int
    ) -> StructureWithBitfields | None: ...
    @overload
    def __parse__(self, fname: str, data: None, fast_load: bool) -> None: ...
    @overload
    def __parse__(self, fname: None, data: _DATA_TYPE, fast_load: bool) -> None: ...
    def parse_rich_header(self) -> dict[str, bytes] | None: ...
    def get_warnings(self) -> list[str]: ...
    def show_warnings(self) -> None: ...
    def full_load(self) -> None: ...
    def write(self, filename: str | None = ...) -> bytes | None: ...
    def parse_sections(self, offset: int) -> None: ...
    def parse_data_directories(
        self,
        directories: list[int] | None = ...,
        forwarded_exports_only: bool = ...,
        import_dllnames_only: bool = ...,
    ) -> None: ...
    def parse_exceptions_directory(
        self, rva: int, size: int
    ) -> list[ExceptionsDirEntryData] | None: ...
    def parse_directory_bound_imports(
        self, rva: int, size: int
    ) -> list[ImportData] | None: ...
    def parse_directory_tls(self, rva: int, size: int) -> TlsData | None: ...
    def parse_directory_load_config(
        self, rva: int, size: int
    ) -> LoadConfigData | None: ...
    def parse_dynamic_relocations(
        self,
        dynamic_value_reloc_table_offset: int,
        dynamic_value_reloc_table_section: int,
    ) -> list[DynamicRelocationData] | None: ...
    def parse_function_override_data(self, rva: int) -> list[FunctionOverrideData]: ...
    def parse_relocations_directory(
        self, rva: int, size: int
    ) -> list[BaseRelocationData]: ...
    def parse_image_base_relocation_list(
        self, rva: int, size: int, fmt: _STRUCTURE_FORMAT | None = ...
    ) -> list[BaseRelocationData]: ...
    def parse_relocations(
        self, data_rva: int, rva: int, size: int
    ) -> list[RelocationData]: ...
    def parse_relocations_with_format(
        self, data_rva: int, rva: int, size: int, format: _STRUCTURE_FORMAT | None
    ) -> list[RelocationData]: ...
    def parse_debug_directory(self, rva: int, size: int) -> list[DebugData] | None: ...
    def parse_resources_directory(
        self,
        rva: int,
        size: int = ...,
        base_rva: int | None = ...,
        level: int = ...,
        dirs: list[int] | None = ...,
    ) -> ResourceDirData | None: ...
    def parse_resource_data_entry(self, rva: int) -> Structure | None: ...
    def parse_resource_entry(self, rva: int) -> Structure | None: ...

    class _VersionStruct:
        OffsetToData: int
        Size: int
    def parse_version_information(self, version_struct: _VersionStruct) -> None: ...
    def parse_export_directory(
        self, rva: int, size: int, forwarded_only: bool = ...
    ) -> ExportDirData | None: ...
    def dword_align(self, offset: int, base: int) -> int: ...
    def normalize_import_va(self, va: int) -> int: ...
    def parse_delay_import_directory(
        self, rva: int, size: int
    ) -> list[ImportDescData]: ...
    def get_rich_header_hash(
        self,
        algorithm: Literal["md5", "sha1", "sha256", "sha512"] = ...,
    ) -> _Hash: ...
    def get_imphash(self) -> str: ...
    def get_exphash(self) -> str: ...
    def parse_import_directory(
        self, rva: int, size: int, dllnames_only: bool = ...
    ) -> list[ImportDescData]: ...
    def parse_imports(
        self,
        original_first_thunk: int,
        first_thunk: int,
        forwarder_chain: Any | None,
        max_length: int | None = ...,
        contains_addresses: bool = ...,
    ) -> list[ImportData]: ...
    def get_import_table(
        self, rva: int, max_length: int | None = ..., contains_addresses: bool = ...
    ) -> list[Structure] | None: ...
    def get_memory_mapped_image(
        self, max_virtual_address: int = ..., ImageBase: int | None = ...
    ) -> bytes: ...
    def get_resources_strings(self) -> list[str]: ...
    def get_data(self, rva: int = ..., length: int | None = ...) -> bytes: ...
    def get_rva_from_offset(self, offset: int) -> int: ...
    def get_offset_from_rva(self, rva: int) -> int: ...
    @overload
    def get_string_at_rva(self, rva: None, max_length: int | None) -> None: ...
    @overload
    def get_string_at_rva(self, rva: int, max_length: int | None = ...) -> bytes: ...
    def get_bytes_from_data(self, offset: int, data: _DATA_TYPE) -> bytes: ...
    def get_string_from_data(self, offset: int, data: _DATA_TYPE) -> bytes: ...
    def get_string_u_at_rva(
        self, rva: int, max_length: int | None = ..., encoding: str | None = ...
    ) -> bytes: ...
    def get_section_by_offset(self, offset: int) -> SectionStructure | None: ...
    def get_section_by_rva(self, rva: int) -> SectionStructure | None: ...
    def __str__(self) -> str: ...
    def has_relocs(self) -> bool: ...
    def has_dynamic_relocs(self) -> bool: ...
    def print_info(self, encoding: str | None = ...) -> None: ...
    def dump_info(self, dump: Dump | None = ..., encoding: str | None = ...) -> str: ...
    def dump_dict(self) -> dict[str, Any]: ...
    def get_physical_by_rva(self, rva: int) -> int: ...
    def get_data_from_dword(self, dword: _DWORD) -> bytes: ...
    def get_dword_from_data(self, data: _DATA_TYPE, offset: int) -> _DWORD | None: ...
    def get_dword_at_rva(self, rva: int) -> _DWORD | None: ...
    def get_dword_from_offset(self, offset: int) -> _DWORD | None: ...
    def set_dword_at_rva(self, rva: int, dword: _DWORD) -> bool: ...
    def set_dword_at_offset(self, offset: int, dword: _DWORD) -> bool: ...
    def get_data_from_word(self, word: _WORD) -> bytes: ...
    def get_word_from_data(self, data: _DATA_TYPE, offset: int) -> _WORD | None: ...
    def get_word_at_rva(self, rva: int) -> _WORD | None: ...
    def get_word_from_offset(self, offset: int) -> _WORD | None: ...
    def set_word_at_rva(self, rva: int, word: _WORD) -> bool: ...
    def set_word_at_offset(self, offset: int, word: _WORD) -> bool: ...
    def get_data_from_qword(self, word: _QWORD) -> bytes: ...
    def get_qword_from_data(self, data: _DATA_TYPE, offset: int) -> _QWORD | None: ...
    def get_qword_at_rva(self, rva: int) -> _QWORD | None: ...
    def get_qword_from_offset(self, offset: int) -> _QWORD | None: ...
    def set_qword_at_rva(self, rva: int, qword: _QWORD) -> bool: ...
    def set_qword_at_offset(self, offset: int, qword: _QWORD) -> bool: ...
    def set_bytes_at_rva(self, rva: int, data: _DATA_TYPE) -> bool: ...
    def set_bytes_at_offset(self, offset: int, data: _DATA_TYPE) -> bool: ...
    def set_data_bytes(self, offset: int, data: _DATA_TYPE) -> None: ...
    def merge_modified_section_data(self) -> None: ...
    def relocate_image(self, new_ImageBase: int) -> None: ...
    def verify_checksum(self) -> bool: ...
    def generate_checksum(self) -> int: ...
    def is_exe(self) -> bool: ...
    def is_dll(self) -> bool: ...
    def is_driver(self) -> bool: ...
    def get_overlay_data_start_offset(self) -> int | None: ...
    def get_overlay(self) -> bytes | None: ...
    def trim(self) -> bytes: ...
    def adjust_FileAlignment(self, val: int, file_alignment: int) -> int: ...
    def adjust_SectionAlignment(
        self, val: int, section_alignment: int, file_alignment: int
    ) -> int: ...

def main() -> None: ...

if __name__ == "__main__": ...
