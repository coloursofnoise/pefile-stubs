"""
This type stub file was generated by pyright.
"""

from contextlib import AbstractContextManager
from types import TracebackType
from . import ordlookup as ordlookup
from typing import Any, Callable, Literal, ParamSpec, Self, TypeVar, TypedDict, overload
from _typeshed import ReadableBuffer
from hashlib import _Hash

_P = ParamSpec("_P")
_T = TypeVar("_T")
_K = TypeVar("_K")
_V = TypeVar("_V")
_DATA_TYPE = ReadableBuffer
_DWORD = int
_WORD = int
_QWORD = int

"""pefile, Portable Executable reader module

All the PE file basic structures are available with their default names as
attributes of the instance returned.

Processed elements such as the import table are made available with lowercase
names, to differentiate them from the upper case basic structure names.

pefile has been tested against many edge cases such as corrupted and malformed
PEs as well as malware, which often attempts to abuse the format way beyond its
standard use. To the best of my knowledge most of the abuse is handled
gracefully.

Copyright (c) 2005-2023 Ero Carrera <ero.carrera@gmail.com>
"""
__author__: str = ...
__version__: str = ...
__contact__: str = ...

long: type[int] = int

def lru_cache(
    maxsize: int = ..., typed: bool = ..., copy: bool = ...
) -> Callable[[Callable[_P, _T]], Callable[_P, _T]]: ...
@lru_cache(maxsize=2048)
def cache_adjust_FileAlignment(val, file_alignment): ...
@lru_cache(maxsize=2048)
def cache_adjust_SectionAlignment(val, section_alignment, file_alignment): ...
def count_zeroes(data: list[int]) -> int: ...

fast_load: bool = ...
MAX_STRING_LENGTH: Literal[0x100000] = ...
MAX_IMPORT_SYMBOLS: Literal[0x2000] = ...
MAX_IMPORT_NAME_LENGTH: Literal[0x200] = ...
MAX_DLL_LENGTH: Literal[0x200] = ...
MAX_SYMBOL_NAME_LENGTH: Literal[0x200] = ...
MAX_SECTIONS: Literal[0x800] = ...
MAX_RESOURCE_ENTRIES: Literal[0x8000] = ...
MAX_RESOURCE_DEPTH: Literal[32] = ...
MAX_SYMBOL_EXPORT_COUNT: Literal[0x2000] = ...
IMAGE_DOS_SIGNATURE: Literal[0x5A4D] = ...
IMAGE_DOSZM_SIGNATURE: Literal[0x4D5A] = ...
IMAGE_NE_SIGNATURE: Literal[0x454E] = ...
IMAGE_LE_SIGNATURE: Literal[0x454C] = ...
IMAGE_LX_SIGNATURE: Literal[0x584C] = ...
IMAGE_TE_SIGNATURE: Literal[0x5A56] = ...
IMAGE_NT_SIGNATURE: Literal[0x00004550] = ...
IMAGE_NUMBEROF_DIRECTORY_ENTRIES: Literal[16] = ...
IMAGE_ORDINAL_FLAG: Literal[0x80000000] = ...
IMAGE_ORDINAL_FLAG64: Literal[0x8000000000000000] = ...
OPTIONAL_HEADER_MAGIC_PE: Literal[0x10B] = ...
OPTIONAL_HEADER_MAGIC_PE_PLUS: Literal[0x20B] = ...

def two_way_dict(pairs: list[tuple[_K, _V]]) -> dict[_K | _V, _K | _V]: ...

_NAME_LOOKUP_LIST = list[tuple[str, bytes]]
_NAME_LOOKUP = dict[str | bytes, str | bytes]

directory_entry_types: _NAME_LOOKUP_LIST = ...
DIRECTORY_ENTRY: _NAME_LOOKUP = ...
image_characteristics: _NAME_LOOKUP_LIST = ...
IMAGE_CHARACTERISTICS: _NAME_LOOKUP = ...
section_characteristics: _NAME_LOOKUP_LIST = ...
SECTION_CHARACTERISTICS: _NAME_LOOKUP = ...
debug_types: _NAME_LOOKUP_LIST = ...
DEBUG_TYPE: _NAME_LOOKUP = ...
subsystem_types: _NAME_LOOKUP_LIST = ...
SUBSYSTEM_TYPE: _NAME_LOOKUP = ...
machine_types: _NAME_LOOKUP_LIST = ...
MACHINE_TYPE: _NAME_LOOKUP = ...
relocation_types: _NAME_LOOKUP_LIST = ...
RELOCATION_TYPE: _NAME_LOOKUP = ...
dll_characteristics: _NAME_LOOKUP_LIST = ...
DLL_CHARACTERISTICS: _NAME_LOOKUP = ...
FILE_ALIGNMENT_HARDCODED_VALUE: Literal[0x200] = ...
unwind_info_flags: _NAME_LOOKUP_LIST = ...
UNWIND_INFO_FLAGS: _NAME_LOOKUP = ...
registers: _NAME_LOOKUP_LIST = ...
REGISTERS: _NAME_LOOKUP = ...
UWOP_PUSH_NONVOL: Literal[0] = ...
UWOP_ALLOC_LARGE: Literal[1] = ...
UWOP_ALLOC_SMALL: Literal[2] = ...
UWOP_SET_FPREG: Literal[3] = ...
UWOP_SAVE_NONVOL: Literal[4] = ...
UWOP_SAVE_NONVOL_FAR: Literal[5] = ...
UWOP_EPILOG: Literal[6] = ...
UWOP_SAVE_XMM128: Literal[8] = ...
UWOP_SAVE_XMM128_FAR: Literal[9] = ...
UWOP_PUSH_MACHFRAME: Literal[10] = ...
resource_type: _NAME_LOOKUP_LIST = ...
RESOURCE_TYPE: _NAME_LOOKUP = ...
lang: _NAME_LOOKUP_LIST = ...
LANG: _NAME_LOOKUP = ...
sublang: _NAME_LOOKUP_LIST = ...
SUBLANG: _NAME_LOOKUP = ...

sublang_name: Any
sublang_value: Any

def get_sublang_name_for_lang(
    lang_value: str | bytes, sublang_value: list[str]
) -> str: ...
def parse_strings(data: str, counter: int, l: list[bytes]) -> None: ...
def retrieve_flags(
    flag_dict: dict[str | bytes, str | bytes], flag_filter: str | bytes
) -> list[tuple[str | bytes, str | bytes]]:
    """Read the flags from a dictionary and return them in a usable form.

    Will return a list of (flag, value) for all flags in "flag_dict"
    matching the filter "flag_filter".
    """
    ...

def set_flags(obj: Any, flag_field: bytes, flags: list[tuple[str, bytes]]) -> None:
    """Will process the flags and set attributes in the object accordingly.

    The object "obj" will gain attributes named after the flags provided in
    "flags" and valued True/False, matching the results of applying each
    flag value from "flags" to flag_field.
    """
    ...

def power_of_two(val: bytes) -> bool: ...
def b(x: _DATA_TYPE) -> bytes: ...

class AddressSet(set[_T]):
    def __init__(self) -> None: ...
    def add(self, value: _T) -> None: ...
    def diff(self) -> _T: ...

class UnicodeStringWrapperPostProcessor:
    """This class attempts to help the process of identifying strings
    that might be plain Unicode or Pascal. A list of strings will be
    wrapped on it with the hope the overlappings will help make the
    decision about their type."""

    def __init__(self, pe: PE, rva_ptr: int) -> None: ...
    def get_rva(self) -> int:
        """Get the RVA of the string."""
        ...
    def __str__(self) -> str:
        """Return the escaped UTF-8 representation of the string."""
        ...
    def decode(self, *args: str) -> str: ...
    def invalidate(self) -> None:
        """Make this instance None, to express it's no known string type."""
        ...
    def render_pascal_16(self) -> None: ...
    def get_pascal_16_length(self) -> Any | Literal[False]: ...
    def ask_unicode_16(self, next_rva_ptr: int) -> bool:
        """The next RVA is taken to be the one immediately following this one.

        Such RVA could indicate the natural end of the string and will be checked
        to see if there's a Unicode NULL character there.
        """
        ...
    def render_unicode_16(self) -> None: ...

class PEFormatError(Exception):
    """Generic PE format error exception."""

    def __init__(self, value: Any) -> None: ...
    def __str__(self) -> str: ...

class Dump:
    """Convenience class for dumping the PE information."""

    def __init__(self) -> None: ...
    def add_lines(self, txt: list[str], indent: int = ...) -> None:
        """Adds a list of lines.

        The list can be indented with the optional argument 'indent'.
        """
        ...
    def add_line(self, txt: str, indent: int = ...) -> None:
        """Adds a line.

        The line can be indented with the optional argument 'indent'.
        """
        ...
    def add(self, txt: str, indent: int = ...) -> None:
        """Adds some text, no newline will be appended.

        The text can be indented with the optional argument 'indent'.
        """
        ...
    def add_header(self, txt: str) -> None:
        """Adds a header element."""
        ...
    def add_newline(self) -> None:
        """Adds a newline."""
        ...
    def get_text(self) -> str:
        """Get the text in its current state."""
        ...

STRUCT_SIZEOF_TYPES: dict[str, int] = ...

_STRUCTURE_FORMAT = tuple[str, tuple[str, ...]]

@lru_cache(maxsize=2048)
def sizeof_type(t): ...
@lru_cache(maxsize=2048, copy=True)
def set_format(format: _STRUCTURE_FORMAT): ...

class _Structure_Dict_Value(TypedDict):
    FileOffset: int
    Offset: int
    Value: str

class Structure:
    """Prepare structure object to extract members from data.

    Format is a list containing definitions for the elements
    of the structure.
    """

    def __init__(
        self,
        format: _STRUCTURE_FORMAT,
        name: str | None = ...,
        file_offset: int | None = ...,
    ) -> None: ...
    def __get_format__(self) -> str: ...
    def get_field_absolute_offset(self, field_name: str) -> int:
        """Return the offset within the field for the requested field in the structure."""
        ...
    def get_field_relative_offset(self, field_name: str) -> int:
        """Return the offset within the structure for the requested field."""
        ...
    def get_file_offset(self) -> int: ...
    def set_file_offset(self, offset: int) -> None: ...
    def all_zeroes(self) -> bool:
        """Returns true is the unpacked data is all zeros."""
        ...
    def sizeof(self) -> int:
        """Return size of the structure."""
        ...
    def __unpack__(self, data: _DATA_TYPE) -> None: ...
    def __pack__(self) -> bytes: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def dump(self, indentation: int = ...) -> list[str]:
        """Returns a string representation of the structure."""
        ...
    def dump_dict(self) -> dict[str, str | _Structure_Dict_Value]:
        """Returns a dictionary representation of the structure."""
        ...

class SectionStructure(Structure):
    """Convenience section handling class."""

    def __init__(self, *argl: Any, **argd: Any) -> None: ...
    def get_PointerToRawData_adj(self) -> int: ...
    def get_VirtualAddress_adj(self) -> int: ...
    def get_data(
        self,
        start: int | None = ...,
        length: int | None = ...,
        ignore_padding: bool = ...,
    ) -> bytes:
        """Get data chunk from a section.

        Allows to query data from the section by passing the
        addresses where the PE file would be loaded by default.
        It is then possible to retrieve code and data by their real
        addresses as they would be if loaded.

        Note that sections on disk can include padding that would
        not be loaded to memory. That is the case if `section.SizeOfRawData`
        is greater than `section.Misc_VirtualSize`, and that means
        that data past `section.Misc_VirtualSize` is padding.
        In case you are not interested in this padding, passing
        `ignore_padding=True` will truncate the result in order
        not to return the padding (if any).

        Returns bytes() under Python 3.x and set() under Python 2.7
        """
        ...
    def __setattr__(self, name: str, val: Any) -> None: ...
    def get_rva_from_offset(self, offset: int) -> int: ...
    def get_offset_from_rva(self, rva: int) -> int: ...
    def contains_offset(self, offset: int) -> bool:
        """Check whether the section contains the file offset provided."""
        ...
    def contains_rva(self, rva: int) -> bool:
        """Check whether the section contains the address provided."""
        ...
    def contains(self, rva: int) -> bool: ...
    def get_entropy(self) -> float | Literal[0]:
        """Calculate and return the entropy for the section."""
        ...
    def get_hash_sha1(self) -> str | None:
        """Get the SHA-1 hex-digest of the section's data."""
        ...
    def get_hash_sha256(self) -> str | None:
        """Get the SHA-256 hex-digest of the section's data."""
        ...
    def get_hash_sha512(self) -> str | None:
        """Get the SHA-512 hex-digest of the section's data."""
        ...
    def get_hash_md5(self) -> str | None:
        """Get the MD5 hex-digest of the section's data."""
        ...
    def entropy_H(self, data: _DATA_TYPE) -> float | Literal[0]:
        """Calculate the entropy of a chunk of data."""
        ...

@lru_cache(maxsize=2048, copy=False)
def set_bitfields_format(
    format,
) -> tuple[
    str,
    int,
    dict[str, int],
    list[str],
    list[str],
    dict[int, tuple[str, list[tuple[str, int]]]],
]: ...

class StructureWithBitfields(Structure):
    """
    Extends Structure's functionality with support for bitfields such as:
        ('B:4,LowerHalf', 'B:4,UpperHalf')
    To this end, two lists are maintained:
        * self.__keys__ that contains compound fields, for example
          ('B,~LowerHalfUpperHalf'), and is used during packing/unpaking
        * self.__keys_ext__ containing a separate key for each field (ex., LowerHalf,
          UpperHalf) to simplify implementation of dump()
    This way the implementation of unpacking/packing and dump() from Structure can be
    reused.

    In addition, we create a dictionary:
        <comound_field_index_in_keys> -->
            (data type, [ (subfield name, length in bits)+ ] )
    that facilitates bitfield paking and unpacking.

    With lru_cache() creating only once instance per format string, the memory
    overhead is negligible.
    """

    BTF_NAME_IDX: Literal[0] = ...
    BTF_BITCNT_IDX: Literal[1] = ...
    CF_TYPE_IDX: Literal[0] = ...
    CF_SUBFLD_IDX: Literal[1] = ...
    def __init__(
        self,
        format: _STRUCTURE_FORMAT,
        name: str | None = ...,
        file_offset: int | None = ...,
    ) -> None: ...
    def __unpack__(self, data: _DATA_TYPE) -> None: ...
    def __pack__(self) -> bytes: ...
    def dump(self, indentation: int = ...) -> list[str]: ...
    def dump_dict(self) -> dict[str, str | _Structure_Dict_Value]: ...

class DataContainer:
    """Generic data container."""

    def __init__(self, **args: Any) -> None: ...

class ImportDescData(DataContainer):
    """Holds import descriptor information.

    dll:        name of the imported DLL
    imports:    list of imported symbols (ImportData instances)
    struct:     IMAGE_IMPORT_DESCRIPTOR structure
    """

    ...

class ImportData(DataContainer):
    """Holds imported symbol's information.

    ordinal:    Ordinal of the symbol
    name:       Name of the symbol
    bound:      If the symbol is bound, this contains
                the address.
    """

    def __setattr__(self, name: str, val: Any) -> None: ...

class ExportDirData(DataContainer):
    """Holds export directory information.

    struct:     IMAGE_EXPORT_DIRECTORY structure
    symbols:    list of exported symbols (ExportData instances)"""

    ...

class ExportData(DataContainer):
    """Holds exported symbols' information.

    ordinal:    ordinal of the symbol
    address:    address of the symbol
    name:       name of the symbol (None if the symbol is
                exported by ordinal only)
    forwarder:  if the symbol is forwarded it will
                contain the name of the target symbol,
                None otherwise.
    """

    def __setattr__(self, name: str, val: Any) -> None: ...

class ResourceDirData(DataContainer):
    """Holds resource directory information.

    struct:     IMAGE_RESOURCE_DIRECTORY structure
    entries:    list of entries (ResourceDirEntryData instances)
    """

    ...

class ResourceDirEntryData(DataContainer):
    """Holds resource directory entry data.

    struct:     IMAGE_RESOURCE_DIRECTORY_ENTRY structure
    name:       If the resource is identified by name this
                attribute will contain the name string. None
                otherwise. If identified by id, the id is
                available at 'struct.Id'
    id:         the id, also in struct.Id
    directory:  If this entry has a lower level directory
                this attribute will point to the
                ResourceDirData instance representing it.
    data:       If this entry has no further lower directories
                and points to the actual resource data, this
                attribute will reference the corresponding
                ResourceDataEntryData instance.
    (Either of the 'directory' or 'data' attribute will exist,
    but not both.)
    """

    ...

class ResourceDataEntryData(DataContainer):
    """Holds resource data entry information.

    struct:     IMAGE_RESOURCE_DATA_ENTRY structure
    lang:       Primary language ID
    sublang:    Sublanguage ID
    """

    ...

class DebugData(DataContainer):
    """Holds debug information.

    struct:     IMAGE_DEBUG_DIRECTORY structure
    entries:    list of entries (IMAGE_DEBUG_TYPE instances)
    """

    ...

class DynamicRelocationData(DataContainer):
    """Holds dynamic relocation information.

    struct:        IMAGE_DYNAMIC_RELOCATION structure
    symbol:        Symbol to which dynamic relocations must be applied
    relocations:   List of dynamic relocations for this symbol (BaseRelocationData instances)
    """

    ...

class FunctionOverrideData(DataContainer):
    """Holds Function and bdd dynamic relocation information.

    struct:        IMAGE_DYNAMIC_RELOCATION structure
    symbol:        Symbol to which dynamic relocations must be applied
    bdd_relocs:    List of bdd dynamic relocations (BddDynamicRelocationData instances)
    func_relocs:   List of function override dynamic relocations (FunctionOverrideDynamicRelocationData instances)
    """

    ...

class FunctionOverrideDynamicRelocationData(DataContainer):
    """Holds Function override dynamic relocation information.

    struct:        IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION structure
    func_rva:      Original function rva
    override_rvas: List of overriding function rvas
    relocations:   List of dynamic relocations (BaseRelocationData instances)
    """

class BddDynamicRelocationData(DataContainer):
    """Holds Bdd dynamic relocation information.

    struct:        IMAGE_BDD_DYNAMIC_RELOCATION structure
    """

class BaseRelocationData(DataContainer):
    """Holds base relocation information.

    struct:     IMAGE_BASE_RELOCATION structure
    entries:    list of relocation data (RelocationData instances)
    """

    ...

class RelocationData(DataContainer):
    """Holds relocation information.

    type:       Type of relocation
                The type string can be obtained by
                RELOCATION_TYPE[type]
    rva:        RVA of the relocation
    """

    def __setattr__(self, name: str, val: Any) -> None: ...

class TlsData(DataContainer):
    """Holds TLS information.

    struct:     IMAGE_TLS_DIRECTORY structure
    """

    ...

class BoundImportDescData(DataContainer):
    """Holds bound import descriptor data.

    This directory entry will provide information on the
    DLLs this PE file has been bound to (if bound at all).
    The structure will contain the name and timestamp of the
    DLL at the time of binding so that the loader can know
    whether it differs from the one currently present in the
    system and must, therefore, re-bind the PE's imports.

    struct:     IMAGE_BOUND_IMPORT_DESCRIPTOR structure
    name:       DLL name
    entries:    list of entries (BoundImportRefData instances)
                the entries will exist if this DLL has forwarded
                symbols. If so, the destination DLL will have an
                entry in this list.
    """

    ...

class LoadConfigData(DataContainer):
    """Holds Load Config data.

    struct:     IMAGE_LOAD_CONFIG_DIRECTORY structure
    name:       dll name
    dynamic_relocations: dynamic relocation information, if present
    """

    ...

class BoundImportRefData(DataContainer):
    """Holds bound import forwarder reference data.

    Contains the same information as the bound descriptor but
    for forwarded DLLs, if any.

    struct:     IMAGE_BOUND_FORWARDER_REF structure
    name:       dll name
    """

    ...

class ExceptionsDirEntryData(DataContainer):
    """Holds the data related to SEH (and stack unwinding, in particular)

    struct      an instance of RUNTIME_FUNTION
    unwindinfo  an instance of UNWIND_INFO
    """

    ...

class UnwindInfo(StructureWithBitfields):
    """Handles the complexities of UNWIND_INFO structure:
    * variable number of UWIND_CODEs
    * optional ExceptionHandler and FunctionEntry fields
    """

    def __init__(self, file_offset: int = ...) -> None: ...
    def unpack_in_stages(self, data: _DATA_TYPE) -> str | None:
        """Unpacks the UNWIND_INFO "in two calls", with the first call establishing
        a full size of the structure and the second, performing the actual unpacking.
        """
        ...
    def dump(self, indentation: int = ...) -> list[str]: ...
    def dump_dict(self) -> dict[str, str | _Structure_Dict_Value]: ...
    def __setattr__(self, name: str, val: Any) -> None: ...
    def sizeof(self) -> int: ...
    def __pack__(self) -> bytes: ...
    def get_chained_function_entry(self) -> ExceptionsDirEntryData: ...
    def set_chained_function_entry(self, entry: ExceptionsDirEntryData) -> None: ...

class PrologEpilogOp:
    """Meant as an abstract class representing a generic unwind code.
    There is a subclass of PrologEpilogOp for each member of UNWIND_OP_CODES enum.
    """

    def initialize(
        self,
        unw_code: StructureWithBitfields,
        data: _DATA_TYPE,
        unw_info: UnwindInfo,
        file_offset: int | None,
    ) -> None: ...
    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int:
        """Computes how many UNWIND_CODE structures UNWIND_CODE occupies.
        May be called before initialize() and, for that reason, should not rely on
        the values of intance attributes.
        """
        ...
    def is_valid(self) -> bool: ...

class PrologEpilogOpPushReg(PrologEpilogOp):
    """UWOP_PUSH_NONVOL"""

    def __str__(self) -> str: ...

class PrologEpilogOpAllocLarge(PrologEpilogOp):
    """UWOP_ALLOC_LARGE"""

    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_alloc_size(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpAllocSmall(PrologEpilogOp):
    """UWOP_ALLOC_SMALL"""

    def get_alloc_size(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSetFP(PrologEpilogOp):
    """UWOP_SET_FPREG"""

    def initialize(
        self,
        unw_code: StructureWithBitfields,
        data: _DATA_TYPE,
        unw_info: UnwindInfo,
        file_offset: int | None,
    ) -> None: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSaveReg(PrologEpilogOp):
    """UWOP_SAVE_NONVOL"""

    def length_in_code_structures(
        self, unwcode: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSaveRegFar(PrologEpilogOp):
    """UWOP_SAVE_NONVOL_FAR"""

    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSaveXMM(PrologEpilogOp):
    """UWOP_SAVE_XMM128"""

    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpSaveXMMFar(PrologEpilogOp):
    """UWOP_SAVE_XMM128_FAR"""

    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def __str__(self) -> str: ...

class PrologEpilogOpPushFrame(PrologEpilogOp):
    """UWOP_PUSH_MACHFRAME"""

    def __str__(self) -> str: ...

class PrologEpilogOpEpilogMarker(PrologEpilogOp):
    """UWOP_EPILOG"""

    def initialize(
        self,
        unw_code: StructureWithBitfields,
        data: _DATA_TYPE,
        unw_info: UnwindInfo,
        file_offset: int | None,
    ) -> None: ...
    def length_in_code_structures(
        self, unw_code: StructureWithBitfields, unw_info: UnwindInfo
    ) -> int: ...
    def get_offset(self) -> int: ...
    def is_valid(self) -> bool: ...
    def __str__(self) -> str: ...

class PrologEpilogOpsFactory:
    """A factory for creating unwind codes based on the value of UnwindOp"""

    _class_dict: dict[int, type[PrologEpilogOp]] = ...
    @staticmethod
    def create(unwcode: StructureWithBitfields) -> PrologEpilogOp: ...

allowed_filename: bytes = ...

def is_valid_dos_filename(s: str | bytes | bytearray) -> bool: ...

allowed_function_name: bytes = ...

@lru_cache(maxsize=2048)
def is_valid_function_name(
    s: str | bytes | bytearray, relax_allowed_characters: bool = ...
) -> bool: ...

class PE(AbstractContextManager["PE"]):
    """A Portable Executable representation.

    This class provides access to most of the information in a PE file.

    It expects to be supplied the name of the file to load or PE data
    to process and an optional argument 'fast_load' (False by default)
    which controls whether to load all the directories information,
    which can be quite time consuming.

    pe = pefile.PE('module.dll')
    pe = pefile.PE(name='module.dll')

    would load 'module.dll' and process it. If the data is already
    available in a buffer the same can be achieved with:

    pe = pefile.PE(data=module_dll_data)

    The "fast_load" can be set to a default by setting its value in the
    module itself by means, for instance, of a "pefile.fast_load = True".
    That will make all the subsequent instances not to load the
    whole PE structure. The "full_load" method can be used to parse
    the missing data at a later stage.

    Basic headers information will be available in the attributes:

    DOS_HEADER
    NT_HEADERS
    FILE_HEADER
    OPTIONAL_HEADER

    All of them will contain among their attributes the members of the
    corresponding structures as defined in WINNT.H

    The raw data corresponding to the header (from the beginning of the
    file up to the start of the first section) will be available in the
    instance's attribute 'header' as a string.

    The sections will be available as a list in the 'sections' attribute.
    Each entry will contain as attributes all the structure's members.

    Directory entries will be available as attributes (if they exist):
    (no other entries are processed at this point)

    DIRECTORY_ENTRY_IMPORT (list of ImportDescData instances)
    DIRECTORY_ENTRY_EXPORT (ExportDirData instance)
    DIRECTORY_ENTRY_RESOURCE (ResourceDirData instance)
    DIRECTORY_ENTRY_DEBUG (list of DebugData instances)
    DIRECTORY_ENTRY_BASERELOC (list of BaseRelocationData instances)
    DIRECTORY_ENTRY_TLS
    DIRECTORY_ENTRY_BOUND_IMPORT (list of BoundImportData instances)

    The following dictionary attributes provide ways of mapping different
    constants. They will accept the numeric value and return the string
    representation and the opposite, feed in the string and get the
    numeric constant:

    DIRECTORY_ENTRY
    IMAGE_CHARACTERISTICS
    SECTION_CHARACTERISTICS
    DEBUG_TYPE
    SUBSYSTEM_TYPE
    MACHINE_TYPE
    RELOCATION_TYPE
    RESOURCE_TYPE
    LANG
    SUBLANG
    """

    __IMAGE_DOS_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_FILE_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DATA_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_OPTIONAL_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_OPTIONAL_HEADER64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_NT_HEADERS_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_SECTION_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DELAY_IMPORT_DESCRIPTOR_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_IMPORT_DESCRIPTOR_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_EXPORT_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_RESOURCE_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_RESOURCE_DIRECTORY_ENTRY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_RESOURCE_DATA_ENTRY_format__: _STRUCTURE_FORMAT = ...
    __VS_VERSIONINFO_format__: _STRUCTURE_FORMAT = ...
    __VS_FIXEDFILEINFO_format__: _STRUCTURE_FORMAT = ...
    __StringFileInfo_format__: _STRUCTURE_FORMAT = ...
    __StringTable_format__: _STRUCTURE_FORMAT = ...
    __String_format__: _STRUCTURE_FORMAT = ...
    __Var_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_THUNK_DATA_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_THUNK_DATA64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DEBUG_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BASE_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BASE_RELOCATION_ENTRY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_FUNCTION_OVERRIDE_HEADER_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_FUNCTION_OVERRIDE_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BDD_INFO_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BDD_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_TLS_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_TLS_DIRECTORY64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_LOAD_CONFIG_DIRECTORY_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_LOAD_CONFIG_DIRECTORY64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION_TABLE_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION64_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION_V2_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_DYNAMIC_RELOCATION64_V2_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BOUND_IMPORT_DESCRIPTOR_format__: _STRUCTURE_FORMAT = ...
    __IMAGE_BOUND_FORWARDER_REF_format__: _STRUCTURE_FORMAT = ...
    __RUNTIME_FUNCTION_format__: _STRUCTURE_FORMAT = ...
    @overload
    def __init__(
        self,
        name: str = ...,
        data: None = ...,
        fast_load: bool | None = ...,
        max_symbol_exports: int = ...,
        max_repeated_symbol: int = ...,
    ) -> None: ...
    @overload
    def __init__(
        self,
        name: None = ...,
        data: _DATA_TYPE = ...,
        fast_load: bool | None = ...,
        max_symbol_exports: int = ...,
        max_repeated_symbol: int = ...,
    ) -> None: ...
    def __enter__(self) -> Self: ...
    def __exit__(
        self,
        type: type[BaseException] | None,
        value: BaseException | None,
        traceback: TracebackType | None,
    ) -> None: ...
    def close(self) -> None: ...
    def __unpack_data__(
        self, format: _STRUCTURE_FORMAT, data: _DATA_TYPE, file_offset: int
    ) -> Structure | None:
        """Apply structure format to raw data.

        Returns an unpacked structure object if successful, None otherwise.
        """
        ...
    def __unpack_data_with_bitfields__(
        self, format: _STRUCTURE_FORMAT, data: _DATA_TYPE, file_offset: int
    ) -> StructureWithBitfields | None:
        """Apply structure format to raw data.

        Returns an unpacked structure object if successful, None otherwise.
        """
        ...
    @overload
    def __parse__(self, fname: str, data: None, fast_load: bool) -> None: ...
    @overload
    def __parse__(self, fname: None, data: _DATA_TYPE, fast_load: bool) -> None:
        """Parse a Portable Executable file.

        Loads a PE file, parsing all its structures and making them available
        through the instance's attributes.
        """
        ...
    def parse_rich_header(self) -> dict[str, bytes] | None:
        """Parses the rich header
        see http://www.ntcore.com/files/richsign.htm for more information

        Structure:
        00 DanS ^ checksum, checksum, checksum, checksum
        10 Symbol RVA ^ checksum, Symbol size ^ checksum...
        ...
        XX Rich, checksum, 0, 0,...
        """
        ...
    def get_warnings(self) -> list[str]:
        """Return the list of warnings.

        Non-critical problems found when parsing the PE file are
        appended to a list of warnings. This method returns the
        full list.
        """
        ...
    def show_warnings(self) -> None:
        """Print the list of warnings.

        Non-critical problems found when parsing the PE file are
        appended to a list of warnings. This method prints the
        full list to standard output.
        """
        ...
    def full_load(self) -> None:
        """Process the data directories.

        This method will load the data directories which might not have
        been loaded if the "fast_load" option was used.
        """
    def write(self, filename: str | None = ...) -> bytes | None:
        """Write the PE file.

        This function will process all headers and components
        of the PE file and include all changes made (by just
        assigning to attributes in the PE objects) and write
        the changes back to a file whose name is provided as
        an argument. The filename is optional, if not
        provided the data will be returned as a 'str' object.
        """
        ...
    def parse_sections(self, offset: int) -> None:
        """Fetch the PE file sections.

        The sections will be readily available in the "sections" attribute.
        Its attributes will contain all the section information plus "data"
        a buffer containing the section's data.

        The "Characteristics" member will be processed and attributes
        representing the section characteristics (with the 'IMAGE_SCN_'
        string trimmed from the constant's names) will be added to the
        section instance.

        Refer to the SectionStructure class for additional info.
        """
        ...
    def parse_data_directories(
        self,
        directories: list[int] | None = ...,
        forwarded_exports_only: bool = ...,
        import_dllnames_only: bool = ...,
    ) -> None:
        """Parse and process the PE file's data directories.

        If the optional argument 'directories' is given, only
        the directories at the specified indexes will be parsed.
        Such functionality allows parsing of areas of interest
        without the burden of having to parse all others.
        The directories can then be specified as:

        For export / import only:

          directories = [ 0, 1 ]

        or (more verbosely):

          directories = [ DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT'],
            DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT'] ]

        If 'directories' is a list, the ones that are processed will be removed,
        leaving only the ones that are not present in the image.

        If `forwarded_exports_only` is True, the IMAGE_DIRECTORY_ENTRY_EXPORT
        attribute will only contain exports that are forwarded to another DLL.

        If `import_dllnames_only` is True, symbols will not be parsed from
        the import table and the entries in the IMAGE_DIRECTORY_ENTRY_IMPORT
        attribute will not have a `symbols` attribute.
        """
        ...
    def parse_exceptions_directory(
        self, rva: int, size: int
    ) -> list[ExceptionsDirEntryData] | None:
        """Parses exception directory

        All the code related to handling exception directories is documented in
        https://auscitte.github.io/systems%20blog/Exception-Directory-pefile#implementation-details
        """
        ...
    def parse_directory_bound_imports(
        self, rva: int, size: int
    ) -> list[ImportData] | None:
        """"""
        ...
    def parse_directory_tls(self, rva: int, size: int) -> TlsData | None:
        """"""
        ...
    def parse_directory_load_config(self, rva: int, size: int) -> LoadConfigData | None:
        """"""
        ...
    def parse_dynamic_relocations(
        self,
        dynamic_value_reloc_table_offset: int,
        dynamic_value_reloc_table_section: int,
    ) -> list[DynamicRelocationData] | None: ...
    def parse_function_override_data(self, rva: int) -> list[FunctionOverrideData]:
        """"""
    def parse_relocations_directory(
        self, rva: int, size: int
    ) -> list[BaseRelocationData]:
        """"""
        ...
    def parse_image_base_relocation_list(
        self, rva: int, size: int, fmt: _STRUCTURE_FORMAT | None = ...
    ) -> list[BaseRelocationData]: ...
    def parse_relocations(
        self, data_rva: int, rva: int, size: int
    ) -> list[RelocationData]:
        """"""
        ...
    def parse_relocations_with_format(
        self, data_rva: int, rva: int, size: int, format: _STRUCTURE_FORMAT | None
    ) -> list[RelocationData]:
        """"""
        ...
    def parse_debug_directory(self, rva: int, size: int) -> list[DebugData] | None:
        """"""
        ...
    def parse_resources_directory(
        self,
        rva: int,
        size: int = ...,
        base_rva: int | None = ...,
        level: int = ...,
        dirs: list[int] | None = ...,
    ) -> ResourceDirData | None:
        """Parse the resources directory.

        Given the RVA of the resources directory, it will process all
        its entries.

        The root will have the corresponding member of its structure,
        IMAGE_RESOURCE_DIRECTORY plus 'entries', a list of all the
        entries in the directory.

        Those entries will have, correspondingly, all the structure's
        members (IMAGE_RESOURCE_DIRECTORY_ENTRY) and an additional one,
        "directory", pointing to the IMAGE_RESOURCE_DIRECTORY structure
        representing upper layers of the tree. This one will also have
        an 'entries' attribute, pointing to the 3rd, and last, level.
        Another directory with more entries. Those last entries will
        have a new attribute (both 'leaf' or 'data_entry' can be used to
        access it). This structure finally points to the resource data.
        All the members of this structure, IMAGE_RESOURCE_DATA_ENTRY,
        are available as its attributes.
        """
        ...
    def parse_resource_data_entry(self, rva: int) -> Structure | None:
        """Parse a data entry from the resources directory."""
        ...
    def parse_resource_entry(self, rva: int) -> Structure | None:
        """Parse a directory entry from the resources directory."""
        ...

    class _VersionStruct:
        OffsetToData: int
        Size: int
    def parse_version_information(self, version_struct: _VersionStruct) -> None:
        """Parse version information structure.

        The date will be made available in three attributes of the PE object.

        VS_VERSIONINFO   will contain the first three fields of the main structure:
            'Length', 'ValueLength', and 'Type'

        VS_FIXEDFILEINFO will hold the rest of the fields, accessible as sub-attributes:
            'Signature', 'StrucVersion', 'FileVersionMS', 'FileVersionLS',
            'ProductVersionMS', 'ProductVersionLS', 'FileFlagsMask', 'FileFlags',
            'FileOS', 'FileType', 'FileSubtype', 'FileDateMS', 'FileDateLS'

        FileInfo    is a list of all StringFileInfo and VarFileInfo structures.

        StringFileInfo structures will have a list as an attribute named 'StringTable'
        containing all the StringTable structures. Each of those structures contains a
        dictionary 'entries' with all the key / value version information string pairs.

        VarFileInfo structures will have a list as an attribute named 'Var' containing
        all Var structures. Each Var structure will have a dictionary as an attribute
        named 'entry' which will contain the name and value of the Var.
        """
        ...
    def parse_export_directory(
        self, rva: int, size: int, forwarded_only: bool = ...
    ) -> ExportDirData | None:
        """Parse the export directory.

        Given the RVA of the export directory, it will process all
        its entries.

        The exports will be made available as a list of ExportData
        instances in the 'IMAGE_DIRECTORY_ENTRY_EXPORT' PE attribute.
        """
        ...
    def dword_align(self, offset: int, base: int) -> int: ...
    def normalize_import_va(self, va: int) -> int: ...
    def parse_delay_import_directory(self, rva: int, size: int) -> list[ImportDescData]:
        """Walk and parse the delay import directory."""
        ...
    def get_rich_header_hash(
        self,
        algorithm: Literal["md5", "sha1", "sha256", "sha512"] = ...,
    ) -> _Hash: ...
    def get_imphash(self) -> str:
        """Return the imphash of the PE file.

        Creates a hash based on imported symbol names and their specific order within
        the executable:
        https://www.mandiant.com/resources/blog/tracking-malware-import-hashing

        Returns:
            the hexdigest of the MD5 hash of the exported symbols.
        """
        ...
    def get_exphash(self) -> str:
        """Return the exphash of the PE file.

        Similar to imphash, but based on exported symbol names and their specific order.

        Returns:
            the hexdigest of the SHA256 hash of the exported symbols.
        """
        ...
    def parse_import_directory(
        self, rva: int, size: int, dllnames_only: bool = ...
    ) -> list[ImportDescData]:
        """Walk and parse the import directory."""
        ...
    def parse_imports(
        self,
        original_first_thunk: int,
        first_thunk: int,
        forwarder_chain: Any | None,
        max_length: int | None = ...,
        contains_addresses: bool = ...,
    ) -> list[ImportData]:
        """Parse the imported symbols.

        It will fill a list, which will be available as the dictionary
        attribute "imports". Its keys will be the DLL names and the values
        of all the symbols imported from that object.
        """
        ...
    def get_import_table(
        self, rva: int, max_length: int | None = ..., contains_addresses: bool = ...
    ) -> list[Structure] | None: ...
    def get_memory_mapped_image(
        self, max_virtual_address: int = ..., ImageBase: int | None = ...
    ) -> bytes:
        """Returns the data corresponding to the memory layout of the PE file.

        The data includes the PE header and the sections loaded at offsets
        corresponding to their relative virtual addresses. (the VirtualAddress
        section header member).
        Any offset in this data corresponds to the absolute memory address
        ImageBase+offset.

        The optional argument 'max_virtual_address' provides with means of limiting
        which sections are processed.
        Any section with their VirtualAddress beyond this value will be skipped.
        Normally, sections with values beyond this range are just there to confuse
        tools. It's a common trick to see in packed executables.

        If the 'ImageBase' optional argument is supplied, the file's relocations
        will be applied to the image by calling the 'relocate_image()' method. Beware
        that the relocation information is applied permanently.
        """
        ...
    def get_resources_strings(self) -> list[str]:
        """Returns a list of all the strings found withing the resources (if any).

        This method will scan all entries in the resources directory of the PE, if
        there is one, and will return a [] with the strings.

        An empty list will be returned otherwise.
        """
        ...
    def get_data(self, rva: int = ..., length: int | None = ...) -> bytes:
        """Get data regardless of the section where it lies on.

        Given a RVA and the size of the chunk to retrieve, this method
        will find the section where the data lies and return the data.
        """
        ...
    def get_rva_from_offset(self, offset: int) -> int:
        """Get the RVA corresponding to this file offset."""
        ...
    def get_offset_from_rva(self, rva: int) -> int:
        """Get the file offset corresponding to this RVA.

        Given a RVA , this method will find the section where the
        data lies and return the offset within the file.
        """
        ...
    @overload
    def get_string_at_rva(self, rva: None, max_length: int | None) -> None: ...
    @overload
    def get_string_at_rva(self, rva: int, max_length: int | None = ...) -> bytes:
        """Get an ASCII string located at the given address."""
        ...
    def get_bytes_from_data(self, offset: int, data: _DATA_TYPE) -> bytes:
        """."""
        ...
    def get_string_from_data(self, offset: int, data: _DATA_TYPE) -> bytes:
        """Get an ASCII string from data."""
        ...
    def get_string_u_at_rva(
        self, rva: int, max_length: int | None = ..., encoding: str | None = ...
    ) -> bytes:
        """Get an Unicode string located at the given address."""
        ...
    def get_section_by_offset(self, offset: int) -> SectionStructure | None:
        """Get the section containing the given file offset."""
        ...
    def get_section_by_rva(self, rva: int) -> SectionStructure | None:
        """Get the section containing the given address."""
        ...
    def __str__(self) -> str: ...
    def has_relocs(self) -> bool:
        """Checks if the PE file has relocation directory"""
        ...
    def has_dynamic_relocs(self) -> bool: ...
    def print_info(self, encoding: str | None = ...) -> None:
        """Print all the PE header information in a human readable from."""
        ...
    def dump_info(self, dump: Dump | None = ..., encoding: str | None = ...) -> str:
        """Dump all the PE header information into human readable string."""
        ...
    def dump_dict(self) -> dict[str, Any]:
        """Dump all the PE header information into a dictionary."""
        ...
    def get_physical_by_rva(self, rva: int) -> int:
        """Gets the physical address in the PE file from an RVA value."""
        ...
    def get_data_from_dword(self, dword: _DWORD) -> bytes:
        """Return a four byte string representing the double word value (little endian)."""
        ...
    def get_dword_from_data(self, data: _DATA_TYPE, offset: int) -> _DWORD | None:
        """Convert four bytes of data to a double word (little endian)

        'offset' is assumed to index into a dword array. So setting it to
        N will return a dword out of the data starting at offset N*4.

        Returns None if the data can't be turned into a double word.
        """
        ...
    def get_dword_at_rva(self, rva: int) -> _DWORD | None:
        """Return the double word value at the given RVA.

        Returns None if the value can't be read, i.e. the RVA can't be mapped
        to a file offset.
        """
        ...
    def get_dword_from_offset(self, offset: int) -> _DWORD | None:
        """Return the double word value at the given file offset. (little endian)"""
        ...
    def set_dword_at_rva(self, rva: int, dword: _DWORD) -> bool:
        """Set the double word value at the file offset corresponding to the given RVA."""
        ...
    def set_dword_at_offset(self, offset: int, dword: _DWORD) -> bool:
        """Set the double word value at the given file offset."""
        ...
    def get_data_from_word(self, word: _WORD) -> bytes:
        """Return a two byte string representing the word value. (little endian)."""
        ...
    def get_word_from_data(self, data: _DATA_TYPE, offset: int) -> _WORD | None:
        """Convert two bytes of data to a word (little endian)

        'offset' is assumed to index into a word array. So setting it to
        N will return a dword out of the data starting at offset N*2.

        Returns None if the data can't be turned into a word.
        """
        ...
    def get_word_at_rva(self, rva: int) -> _WORD | None:
        """Return the word value at the given RVA.

        Returns None if the value can't be read, i.e. the RVA can't be mapped
        to a file offset.
        """
        ...
    def get_word_from_offset(self, offset: int) -> _WORD | None:
        """Return the word value at the given file offset. (little endian)"""
        ...
    def set_word_at_rva(self, rva: int, word: _WORD) -> bool:
        """Set the word value at the file offset corresponding to the given RVA."""
        ...
    def set_word_at_offset(self, offset: int, word: _WORD) -> bool:
        """Set the word value at the given file offset."""
        ...
    def get_data_from_qword(self, word: _QWORD) -> bytes:
        """Return an eight byte string representing the quad-word value (little endian)."""
        ...
    def get_qword_from_data(self, data: _DATA_TYPE, offset: int) -> _QWORD | None:
        """Convert eight bytes of data to a word (little endian)

        'offset' is assumed to index into a word array. So setting it to
        N will return a dword out of the data starting at offset N*8.

        Returns None if the data can't be turned into a quad word.
        """
        ...
    def get_qword_at_rva(self, rva: int) -> _QWORD | None:
        """Return the quad-word value at the given RVA.

        Returns None if the value can't be read, i.e. the RVA can't be mapped
        to a file offset.
        """
        ...
    def get_qword_from_offset(self, offset: int) -> _QWORD | None:
        """Return the quad-word value at the given file offset. (little endian)"""
        ...
    def set_qword_at_rva(self, rva: int, qword: _QWORD) -> bool:
        """Set the quad-word value at the file offset corresponding to the given RVA."""
        ...
    def set_qword_at_offset(self, offset: int, qword: _QWORD) -> bool:
        """Set the quad-word value at the given file offset."""
        ...
    def set_bytes_at_rva(self, rva: int, data: _DATA_TYPE) -> bool:
        """Overwrite, with the given string, the bytes at the file offset corresponding
        to the given RVA.

        Return True if successful, False otherwise. It can fail if the
        offset is outside the file's boundaries.
        """
        ...
    def set_bytes_at_offset(self, offset: int, data: _DATA_TYPE) -> bool:
        """Overwrite the bytes at the given file offset with the given string.

        Return True if successful, False otherwise. It can fail if the
        offset is outside the file's boundaries.
        """
        ...
    def set_data_bytes(self, offset: int, data: _DATA_TYPE) -> None: ...
    def merge_modified_section_data(self) -> None:
        """Update the PE image content with any individual section data that has been
        modified.
        """
        ...
    def relocate_image(self, new_ImageBase: int) -> None:
        """Apply the relocation information to the image using the provided image base.

        This method will apply the relocation information to the image. Given the new
        base, all the relocations will be processed and both the raw data and the
        section's data will be fixed accordingly.
        The resulting image can be retrieved as well through the method:

            get_memory_mapped_image()

        In order to get something that would more closely match what could be found in
        memory once the Windows loader finished its work.
        """
        ...
    def verify_checksum(self) -> bool: ...
    def generate_checksum(self) -> int: ...
    def is_exe(self) -> bool:
        """Check whether the file is a standard executable.

        This will return true only if the file has the IMAGE_FILE_EXECUTABLE_IMAGE flag
        set and the IMAGE_FILE_DLL not set and the file does not appear to be a driver
        either.
        """
        ...
    def is_dll(self) -> bool:
        """Check whether the file is a standard DLL.

        This will return true only if the image has the IMAGE_FILE_DLL flag set.
        """
        ...
    def is_driver(self) -> bool:
        """Check whether the file is a Windows driver.

        This will return true only if there are reliable indicators of the image
        being a driver.
        """
        ...
    def get_overlay_data_start_offset(self) -> int | None:
        """Get the offset of data appended to the file and not contained within
        the area described in the headers."""
        ...
    def get_overlay(self) -> bytes | None:
        """Get the data appended to the file and not contained within the area described
        in the headers."""
        ...
    def trim(self) -> bytes:
        """Return the just data defined by the PE headers, removing any overlaid data."""
        ...
    def adjust_FileAlignment(self, val: int, file_alignment: int) -> int: ...
    def adjust_SectionAlignment(
        self, val: int, section_alignment: int, file_alignment: int
    ) -> int: ...

def main() -> None: ...

if __name__ == "__main__": ...
